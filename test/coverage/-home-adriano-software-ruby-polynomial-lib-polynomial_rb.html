<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>
      /home/adriano/software/ruby/polynomial/lib/polynomial.rb - C0 code
      coverage information
    </title>
    <style type='text/css'>
      body { background-color: rgb(240, 240, 245); }
    </style>
    <style type='text/css'>
      span.cross-ref-title { font-size: 140%; } span.cross-ref a {
      text-decoration: none; } span.cross-ref { background-color:#f3f7fa;
      border: 1px dashed #333; margin: 1em; padding: 0.5em; overflow: hidden; }
      a.crossref-toggle { text-decoration: none; } span.marked0 {
      background-color: rgb(185, 210, 200); display: block; } span.marked1 {
      background-color: rgb(190, 215, 205); display: block; } span.inferred0 {
      background-color: rgb(175, 200, 200); display: block; } span.inferred1 {
      background-color: rgb(180, 205, 205); display: block; } span.uncovered0 {
      background-color: rgb(225, 110, 110); display: block; } span.uncovered1 {
      background-color: rgb(235, 120, 120); display: block; } span.overview {
      border-bottom: 8px solid black; } div.overview { border-bottom: 8px solid
      black; } body { font-family: verdana, arial, helvetica; } div.footer {
      font-size: 68%; margin-top: 1.5em; } h1, h2, h3, h4, h5, h6 {
      margin-bottom: 0.5em; } h5 { margin-top: 0.5em; } .hidden { display: none;
      } div.separator { height: 10px; } /* Commented out for better readability,
      esp. on IE */ /* table tr td, table tr th { font-size: 68%; } td.value
      table tr td { font-size: 11px; } */ table.percent_graph { height: 12px;
      border: #808080 1px solid; empty-cells: show; } table.percent_graph
      td.covered { height: 10px; background: #00f000; } table.percent_graph
      td.uncovered { height: 10px; background: #e00000; } table.percent_graph
      td.NA { height: 10px; background: #eaeaea; } table.report {
      border-collapse: collapse; width: 100%; } table.report td.heading {
      background: #dcecff; border: #d0d0d0 1px solid; font-weight: bold;
      text-align: center; } table.report td.heading:hover { background: #c0ffc0;
      } table.report td.text { border: #d0d0d0 1px solid; } table.report
      td.value, table.report td.lines_total, table.report td.lines_code {
      text-align: right; border: #d0d0d0 1px solid; } table.report tr.light {
      background-color: rgb(240, 240, 245); } table.report tr.dark {
      background-color: rgb(230, 230, 235); } 
    </style>
    <script type='text/javascript'>
       // <![CDATA[ function toggleCode( id ) { if ( document.getElementById )
      elem = document.getElementById( id ); else if ( document.all ) elem =
      eval( "document.all." + id ); else return false; elemStyle = elem.style;
      if ( elemStyle.display != "block" ) { elemStyle.display = "block" } else {
      elemStyle.display = "none" } return true; } // Make cross-references
      hidden by default document.writeln( "<style
      type=\"text/css\">span.cross-ref { display: none }</style>" ) // ]]> 
    </script>
    <style type='text/css'>
      span.run0 { background-color: rgb(178, 204, 255); display: block; }
      span.run1 { background-color: rgb(178, 206, 255); display: block; }
      span.run2 { background-color: rgb(178, 209, 255); display: block; }
      span.run3 { background-color: rgb(178, 211, 255); display: block; }
      span.run4 { background-color: rgb(178, 214, 255); display: block; }
      span.run5 { background-color: rgb(178, 218, 255); display: block; }
      span.run6 { background-color: rgb(178, 220, 255); display: block; }
      span.run7 { background-color: rgb(178, 223, 255); display: block; }
      span.run8 { background-color: rgb(178, 225, 255); display: block; }
      span.run9 { background-color: rgb(178, 228, 255); display: block; }
      span.run10 { background-color: rgb(178, 232, 255); display: block; }
      span.run11 { background-color: rgb(178, 234, 255); display: block; }
      span.run12 { background-color: rgb(178, 237, 255); display: block; }
      span.run13 { background-color: rgb(178, 239, 255); display: block; }
      span.run14 { background-color: rgb(178, 242, 255); display: block; }
      span.run15 { background-color: rgb(178, 246, 255); display: block; }
      span.run16 { background-color: rgb(178, 248, 255); display: block; }
      span.run17 { background-color: rgb(178, 251, 255); display: block; }
      span.run18 { background-color: rgb(178, 253, 255); display: block; }
      span.run19 { background-color: rgb(178, 255, 253); display: block; }
      span.run20 { background-color: rgb(178, 255, 249); display: block; }
      span.run21 { background-color: rgb(178, 255, 247); display: block; }
      span.run22 { background-color: rgb(178, 255, 244); display: block; }
      span.run23 { background-color: rgb(178, 255, 242); display: block; }
      span.run24 { background-color: rgb(178, 255, 239); display: block; }
      span.run25 { background-color: rgb(178, 255, 235); display: block; }
      span.run26 { background-color: rgb(178, 255, 233); display: block; }
      span.run27 { background-color: rgb(178, 255, 230); display: block; }
      span.run28 { background-color: rgb(178, 255, 228); display: block; }
      span.run29 { background-color: rgb(178, 255, 225); display: block; }
      span.run30 { background-color: rgb(178, 255, 221); display: block; }
      span.run31 { background-color: rgb(178, 255, 219); display: block; }
      span.run32 { background-color: rgb(178, 255, 216); display: block; }
      span.run33 { background-color: rgb(178, 255, 214); display: block; }
      span.run34 { background-color: rgb(178, 255, 211); display: block; }
      span.run35 { background-color: rgb(178, 255, 207); display: block; }
      span.run36 { background-color: rgb(178, 255, 205); display: block; }
      span.run37 { background-color: rgb(178, 255, 202); display: block; }
      span.run38 { background-color: rgb(178, 255, 200); display: block; }
      span.run39 { background-color: rgb(178, 255, 197); display: block; }
      span.run40 { background-color: rgb(178, 255, 193); display: block; }
      span.run41 { background-color: rgb(178, 255, 191); display: block; }
      span.run42 { background-color: rgb(178, 255, 188); display: block; }
      span.run43 { background-color: rgb(178, 255, 186); display: block; }
      span.run44 { background-color: rgb(178, 255, 183); display: block; }
      span.run45 { background-color: rgb(178, 255, 179); display: block; }
      span.run46 { background-color: rgb(179, 255, 178); display: block; }
      span.run47 { background-color: rgb(182, 255, 178); display: block; }
      span.run48 { background-color: rgb(184, 255, 178); display: block; }
      span.run49 { background-color: rgb(187, 255, 178); display: block; }
      span.run50 { background-color: rgb(191, 255, 178); display: block; }
      span.run51 { background-color: rgb(193, 255, 178); display: block; }
      span.run52 { background-color: rgb(196, 255, 178); display: block; }
      span.run53 { background-color: rgb(198, 255, 178); display: block; }
      span.run54 { background-color: rgb(201, 255, 178); display: block; }
      span.run55 { background-color: rgb(205, 255, 178); display: block; }
      span.run56 { background-color: rgb(207, 255, 178); display: block; }
      span.run57 { background-color: rgb(210, 255, 178); display: block; }
      span.run58 { background-color: rgb(212, 255, 178); display: block; }
      span.run59 { background-color: rgb(215, 255, 178); display: block; }
      span.run60 { background-color: rgb(219, 255, 178); display: block; }
      span.run61 { background-color: rgb(221, 255, 178); display: block; }
      span.run62 { background-color: rgb(224, 255, 178); display: block; }
      span.run63 { background-color: rgb(226, 255, 178); display: block; }
      span.run64 { background-color: rgb(229, 255, 178); display: block; }
      span.run65 { background-color: rgb(233, 255, 178); display: block; }
      span.run66 { background-color: rgb(235, 255, 178); display: block; }
      span.run67 { background-color: rgb(238, 255, 178); display: block; }
      span.run68 { background-color: rgb(240, 255, 178); display: block; }
      span.run69 { background-color: rgb(243, 255, 178); display: block; }
      span.run70 { background-color: rgb(247, 255, 178); display: block; }
      span.run71 { background-color: rgb(249, 255, 178); display: block; }
      span.run72 { background-color: rgb(252, 255, 178); display: block; }
      span.run73 { background-color: rgb(255, 255, 178); display: block; }
      span.run74 { background-color: rgb(255, 252, 178); display: block; }
      span.run75 { background-color: rgb(255, 248, 178); display: block; }
      span.run76 { background-color: rgb(255, 246, 178); display: block; }
      span.run77 { background-color: rgb(255, 243, 178); display: block; }
      span.run78 { background-color: rgb(255, 240, 178); display: block; }
      span.run79 { background-color: rgb(255, 238, 178); display: block; }
      span.run80 { background-color: rgb(255, 234, 178); display: block; }
      span.run81 { background-color: rgb(255, 232, 178); display: block; }
      span.run82 { background-color: rgb(255, 229, 178); display: block; }
      span.run83 { background-color: rgb(255, 226, 178); display: block; }
      span.run84 { background-color: rgb(255, 224, 178); display: block; }
      span.run85 { background-color: rgb(255, 220, 178); display: block; }
      span.run86 { background-color: rgb(255, 218, 178); display: block; }
      span.run87 { background-color: rgb(255, 215, 178); display: block; }
      span.run88 { background-color: rgb(255, 212, 178); display: block; }
      span.run89 { background-color: rgb(255, 210, 178); display: block; }
      span.run90 { background-color: rgb(255, 206, 178); display: block; }
      span.run91 { background-color: rgb(255, 204, 178); display: block; }
      span.run92 { background-color: rgb(255, 201, 178); display: block; }
      span.run93 { background-color: rgb(255, 198, 178); display: block; }
      span.run94 { background-color: rgb(255, 196, 178); display: block; }
      span.run95 { background-color: rgb(255, 192, 178); display: block; }
      span.run96 { background-color: rgb(255, 189, 178); display: block; }
      span.run97 { background-color: rgb(255, 187, 178); display: block; }
      span.run98 { background-color: rgb(255, 184, 178); display: block; }
      span.run99 { background-color: rgb(255, 182, 178); display: block; }
      span.run100 { background-color: rgb(255, 178, 178); display: block; } 
    </style>
  </head>
  <body>
    <h3>
      C0 code coverage information
    </h3>
    <p>
      Generated on Mon Jun 22 03:54:39 -0300 2009 with 
      <a href='http://eigenclass.org/hiki/rcov'>
        rcov 0.8.1.2
      </a>
    </p>
    <hr />
    <pre><span class='marked0'>Code reported as executed by Ruby looks like
    this... </span><span class='marked1'>and this: this line is also marked as
    covered. </span><span class='inferred0'>Lines considered as run by rcov, but
    not reported by Ruby, look like this, </span><span class='inferred1'>and
    this: these lines were inferred by rcov (using simple heuristics).
    </span><span class='uncovered0'>Finally, here&apos;s a line marked as not
    executed. </span></pre> 
    <table class='report'> <thead> <tr> <td class='heading'> Name </td> <td
    class='heading'> Total lines </td> <td class='heading'> Lines of code </td>
    <td class='heading'> Total coverage </td> <td class='heading'> Code coverage
    </td> </tr> </thead> <tbody> <tr class='light'> <td> <a
    href='-home-adriano-software-ruby-polynomial-lib-polynomial_rb.html'>
    /home/adriano/software/ruby/polynomial/lib/polynomial.rb </a> </td> <td
    class='lines_total'> <tt> 471 </tt> </td> <td class='lines_code'> <tt> 326
    </tt> </td> <td> <table cellspacing='0' align='right' cellpadding='0'> <tr>
    <td> <tt class='coverage_total'> 98.1% </tt> &nbsp; </td> <td> <table
    class='percent_graph' cellspacing='0' cellpadding='0' width='100'> <tr> <td
    class='covered' width='98' /> <td class='uncovered' width='2' /> </tr>
    </table> </td> </tr> </table> </td> <td> <table cellspacing='0'
    align='right' cellpadding='0'> <tr> <td> <tt class='coverage_code'> 97.2%
    </tt> &nbsp; </td> <td> <table class='percent_graph' cellspacing='0'
    cellpadding='0' width='100'> <tr> <td class='covered' width='97' /> <td
    class='uncovered' width='3' /> </tr> </table> </td> </tr> </table> </td>
    </tr> </tbody> </table><pre><span class="marked1"><a name="line1"></a> 1
    begin </span><span class="marked0"><a name="line2"></a> 2 require
    'handy_hash' </span><span class="uncovered1"><a name="line3"></a> 3 rescue
    LoadError </span><span class="uncovered0"><a name="line4"></a> 4
    $stderr.puts 'HandyHash not be loaded, abbreviations not enabled'
    </span><span class="uncovered1"><a name="line5"></a> 5 Hash.class_eval {
    alias merge_abbrv merge } </span><span class="uncovered0"><a
    name="line6"></a> 6 end </span><span class="inferred1"><a name="line7"></a>
    7 </span><span class="inferred0"><a name="line8"></a> 8 # Polynomials on a
    single variable. </span><span class="inferred1"><a name="line9"></a> 9 #
    </span><span class="marked0"><a name="line10"></a> 10 class Polynomial
    </span><span class="inferred1"><a name="line11"></a> 11 </span><span
    class="marked0"><a name="line12"></a> 12 class &lt;&lt;self </span><span
    class="marked1"><a name="line13"></a> 13 alias [] new </span><span
    class="inferred0"><a name="line14"></a> 14 end </span><span
    class="inferred1"><a name="line15"></a> 15 </span><span class="inferred0"><a
    name="line16"></a> 16 # Creates a new polynomial with provided coefficients,
    which are interpreted </span><span class="inferred1"><a name="line17"></a>
    17 # as corresponding to increasing powers of _x_. Alternatively, a hash
    </span><span class="inferred0"><a name="line18"></a> 18 # of
    power=&gt;coefficients may be supplied, as well as the polynomial
    </span><span class="inferred1"><a name="line19"></a> 19 # degree plus a
    block to compute each coefficient from correspoding degree. </span><span
    class="inferred0"><a name="line20"></a> 20 # If a string, optionally
    followed by a arguments hash, is supplied, </span><span class="inferred1"><a
    name="line21"></a> 21 # from_string is called. </span><span
    class="inferred0"><a name="line22"></a> 22 # </span><span
    class="inferred1"><a name="line23"></a> 23 # Examples: </span><span
    class="inferred0"><a name="line24"></a> 24 # Polynomial.new(1, 2).to_s
    #=&gt; 1 + 2*x </span><span class="inferred1"><a name="line25"></a> 25 #
    Polynomial.new(1, Complex(2,3)).to_s #=&gt; 1 + (2+3i)*x </span><span
    class="inferred0"><a name="line26"></a> 26 # Polynomial.new(1) {|n| n+1
    }.to_s #=&gt; 1 + 2*x </span><span class="inferred1"><a name="line27"></a>
    27 # Polynomial[3, 4, 5].to_s #=&gt; 3 + 4*x + 5x**2 </span><span
    class="inferred0"><a name="line28"></a> 28 # Polynomial[1 =&gt; 2, 3 =&gt;
    4].to_s #=&gt; 2*x + 4x**3 </span><span class="inferred1"><a
    name="line29"></a> 29 # Polynomial['x^2-1', :power_symbol=&gt;'^'].to_s
    #=&gt; -1 + x**2 </span><span class="inferred0"><a name="line30"></a> 30 #
    </span><span class="marked1"><a name="line31"></a> 31 def initialize(*coefs)
    </span><span class="marked0"><a name="line32"></a> 32 case coefs[0]
    </span><span class="marked1"><a name="line33"></a> 33 when Integer
    </span><span class="marked0"><a name="line34"></a> 34 if block_given?
    </span><span class="marked1"><a name="line35"></a> 35 coefs =
    0.upto(coefs[0]).map {|degree| yield(degree) } </span><span
    class="inferred0"><a name="line36"></a> 36 end </span><span
    class="marked1"><a name="line37"></a> 37 when Hash </span><span
    class="marked0"><a name="line38"></a> 38 coefs =
    self.class.coefs_from_pow_coefs(coefs[0]) </span><span class="marked1"><a
    name="line39"></a> 39 when String </span><span class="marked0"><a
    name="line40"></a> 40 coefs = self.class.coefs_from_string(coefs[0],
    coefs[1] || {}) </span><span class="inferred1"><a name="line41"></a> 41 else
    </span><span class="marked0"><a name="line42"></a> 42 coefs.flatten!
    </span><span class="marked1"><a name="line43"></a> 43 if coefs.empty?
    </span><span class="marked0"><a name="line44"></a> 44 raise ArgumentError,
    'at least one coefficient should be supplied' </span><span
    class="marked1"><a name="line45"></a> 45 elsif !coefs.all? {|c| c.is_a?
    Numeric } </span><span class="marked0"><a name="line46"></a> 46 raise
    TypeError, 'non-Numeric coefficient supplied' </span><span
    class="inferred1"><a name="line47"></a> 47 end </span><span
    class="inferred0"><a name="line48"></a> 48 end </span><span
    class="marked1"><a name="line49"></a> 49 @coefs =
    Polynomial.remove_trailing_zeroes(coefs) </span><span class="inferred0"><a
    name="line50"></a> 50 end </span><span class="inferred1"><a
    name="line51"></a> 51 </span><span class="inferred0"><a name="line52"></a>
    52 # Creates Polynomial from a String in appropriate format. </span><span
    class="inferred1"><a name="line53"></a> 53 # Coefficients must be integers
    or decimals (interpreted as floats). </span><span class="inferred0"><a
    name="line54"></a> 54 # </span><span class="inferred1"><a name="line55"></a>
    55 # Warning: complex coefficients are not currently accepted. </span><span
    class="inferred0"><a name="line56"></a> 56 # </span><span
    class="inferred1"><a name="line57"></a> 57 # Examples: </span><span
    class="inferred0"><a name="line58"></a> 58 # Polynomial.from_string(&quot;1
    - 7*x**2&quot;) == Polynomial.new(1,0,-7) #=&gt; true </span><span
    class="inferred1"><a name="line59"></a> 59 # Polynomial.from_string(&quot;3
    + 4.1x + 5x^2&quot;, :multiplication_symbol=&gt;'', :power_symbol=&gt;'^')
    == Polynomial.new(3,4.1,5) #=&gt; true </span><span class="inferred0"><a
    name="line60"></a> 60 # Polynomial.from_string(&quot;-3*y&quot;,
    :variable_name=&gt;'y') == Polynomial.new(0,-3) #=&gt; true </span><span
    class="inferred1"><a name="line61"></a> 61 # Polynomial.from_string('x^2-1',
    :power_symbol=&gt;'^').to_s #=&gt; -1 + x**2 </span><span
    class="inferred0"><a name="line62"></a> 62 # </span><span class="marked1"><a
    name="line63"></a> 63 FromStringDefaults = HandyHash[ </span><span
    class="inferred0"><a name="line64"></a> 64 :power_symbol =&gt; '**',
    </span><span class="inferred1"><a name="line65"></a> 65
    :multiplication_symbol =&gt; '*', </span><span class="inferred0"><a
    name="line66"></a> 66 :variable_name =&gt; 'x', </span><span
    class="inferred1"><a name="line67"></a> 67 ] </span><span class="marked0"><a
    name="line68"></a> 68 def self.from_string(s, params={}) </span><span
    class="marked1"><a name="line69"></a> 69
    Polynomial.new(self.coefs_from_string(s,
    FromStringDefaults.merge_abbrv(params))) </span><span class="inferred0"><a
    name="line70"></a> 70 end </span><span class="inferred1"><a
    name="line71"></a> 71 </span><span class="inferred0"><a name="line72"></a>
    72 # Degree of the polynomial (i.e., highest not null power of the
    variable). </span><span class="inferred1"><a name="line73"></a> 73 #
    </span><span class="marked0"><a name="line74"></a> 74 def degree
    </span><span class="marked1"><a name="line75"></a> 75 @coefs.size-1
    </span><span class="inferred0"><a name="line76"></a> 76 end </span><span
    class="inferred1"><a name="line77"></a> 77 </span><span class="inferred0"><a
    name="line78"></a> 78 # Evaluates Polynomial of degree _n_ at point _x_ in
    O(_n_) time using Horner's rule. </span><span class="inferred1"><a
    name="line79"></a> 79 # </span><span class="marked0"><a name="line80"></a>
    80 def substitute(x) </span><span class="marked1"><a name="line81"></a> 81
    total = @coefs.last </span><span class="marked0"><a name="line82"></a> 82
    @coefs[0..-2].reverse.each do |a| </span><span class="marked1"><a
    name="line83"></a> 83 total = total * x + a </span><span
    class="inferred0"><a name="line84"></a> 84 end </span><span
    class="marked1"><a name="line85"></a> 85 total </span><span
    class="inferred0"><a name="line86"></a> 86 end </span><span
    class="inferred1"><a name="line87"></a> 87 </span><span class="marked0"><a
    name="line88"></a> 88 def zero? </span><span class="marked1"><a
    name="line89"></a> 89 @coefs == [0] </span><span class="inferred0"><a
    name="line90"></a> 90 end </span><span class="inferred1"><a
    name="line91"></a> 91 </span><span class="inferred0"><a name="line92"></a>
    92 # Returns an array with the 1st, 2nd, ..., +degree+ derivatives (all
    </span><span class="inferred1"><a name="line93"></a> 93 # subsequent ones
    are null anyway). </span><span class="inferred0"><a name="line94"></a> 94 #
    </span><span class="marked1"><a name="line95"></a> 95 def derivatives
    </span><span class="marked0"><a name="line96"></a> 96 ds = [] </span><span
    class="marked1"><a name="line97"></a> 97 d = self </span><span
    class="inferred0"><a name="line98"></a> 98 begin </span><span
    class="marked1"><a name="line99"></a> 99 d = d.derivative </span><span
    class="marked0"><a name="line100"></a>100 ds &lt;&lt; d </span><span
    class="marked1"><a name="line101"></a>101 end until d.zero? </span><span
    class="marked0"><a name="line102"></a>102 ds </span><span
    class="inferred1"><a name="line103"></a>103 end </span><span
    class="inferred0"><a name="line104"></a>104 </span><span class="marked1"><a
    name="line105"></a>105 def coerce(other) </span><span class="marked0"><a
    name="line106"></a>106 case other </span><span class="marked1"><a
    name="line107"></a>107 when Numeric </span><span class="marked0"><a
    name="line108"></a>108 [Polynomial.new(other), self] </span><span
    class="marked1"><a name="line109"></a>109 when Polynomial </span><span
    class="marked0"><a name="line110"></a>110 [other, self] </span><span
    class="inferred1"><a name="line111"></a>111 else </span><span
    class="marked0"><a name="line112"></a>112 raise TypeError,
    &quot;#{other.class} can't be coerced into Polynomial&quot; </span><span
    class="inferred1"><a name="line113"></a>113 end </span><span
    class="inferred0"><a name="line114"></a>114 end </span><span
    class="inferred1"><a name="line115"></a>115 </span><span
    class="inferred0"><a name="line116"></a>116 # Add another Polynomial or
    Numeric object. </span><span class="inferred1"><a name="line117"></a>117 #
    </span><span class="marked0"><a name="line118"></a>118 def +(other)
    </span><span class="marked1"><a name="line119"></a>119 case other
    </span><span class="marked0"><a name="line120"></a>120 when Numeric
    </span><span class="marked1"><a name="line121"></a>121 self +
    Polynomial.new(other) </span><span class="inferred0"><a
    name="line122"></a>122 else </span><span class="marked1"><a
    name="line123"></a>123 small, big = [self, other].sort </span><span
    class="marked0"><a name="line124"></a>124 a = big.coefs </span><span
    class="marked1"><a name="line125"></a>125 for n in 0 .. small.degree
    </span><span class="marked0"><a name="line126"></a>126 a[n] +=
    small.coefs[n] </span><span class="inferred1"><a name="line127"></a>127 end
    </span><span class="marked0"><a name="line128"></a>128 Polynomial.new(a)
    </span><span class="inferred1"><a name="line129"></a>129 end </span><span
    class="inferred0"><a name="line130"></a>130 end </span><span
    class="inferred1"><a name="line131"></a>131 </span><span
    class="inferred0"><a name="line132"></a>132 # Generates a Polynomial object
    with negated coefficients. </span><span class="inferred1"><a
    name="line133"></a>133 # </span><span class="marked0"><a
    name="line134"></a>134 def -@ </span><span class="marked1"><a
    name="line135"></a>135 Polynomial.new(coefs.map {|x| -x}) </span><span
    class="inferred0"><a name="line136"></a>136 end </span><span
    class="inferred1"><a name="line137"></a>137 </span><span
    class="inferred0"><a name="line138"></a>138 # Subtract another Polynomial or
    Numeric object. </span><span class="inferred1"><a name="line139"></a>139 #
    </span><span class="marked0"><a name="line140"></a>140 def -(other)
    </span><span class="marked1"><a name="line141"></a>141 self + (-other)
    </span><span class="inferred0"><a name="line142"></a>142 end </span><span
    class="inferred1"><a name="line143"></a>143 </span><span
    class="inferred0"><a name="line144"></a>144 # Multiply by another Polynomial
    or Numeric object. </span><span class="inferred1"><a name="line145"></a>145
    # As the straightforward algorithm is used, multipling two polynomials of
    </span><span class="inferred0"><a name="line146"></a>146 # degree _m_ and
    _n_ takes O(_m_ _n_) operations. It is well-known, though, </span><span
    class="inferred1"><a name="line147"></a>147 # that the Fast Fourier
    Transform may be employed to reduce the time </span><span
    class="inferred0"><a name="line148"></a>148 # complexity to O(_K_ log _K_),
    where _K_ = max{_m_, _n_}. </span><span class="inferred1"><a
    name="line149"></a>149 # </span><span class="marked0"><a
    name="line150"></a>150 def *(other) </span><span class="marked1"><a
    name="line151"></a>151 case other </span><span class="marked0"><a
    name="line152"></a>152 when Numeric </span><span class="marked1"><a
    name="line153"></a>153 result_coefs = @coefs.map {|a| a * other}
    </span><span class="inferred0"><a name="line154"></a>154 else </span><span
    class="marked1"><a name="line155"></a>155 result_coefs = [0] * (self.degree
    + other.degree + 2) </span><span class="marked0"><a name="line156"></a>156
    for m in 0 .. self.degree </span><span class="marked1"><a
    name="line157"></a>157 for n in 0 .. other.degree </span><span
    class="marked0"><a name="line158"></a>158 result_coefs[m+n] += @coefs[m] *
    other.coefs[n] </span><span class="inferred1"><a name="line159"></a>159 end
    </span><span class="inferred0"><a name="line160"></a>160 end </span><span
    class="inferred1"><a name="line161"></a>161 end </span><span
    class="marked0"><a name="line162"></a>162 Polynomial.new(result_coefs)
    </span><span class="inferred1"><a name="line163"></a>163 end </span><span
    class="inferred0"><a name="line164"></a>164 </span><span
    class="inferred1"><a name="line165"></a>165 # Divides by +divisor+ (using
    coefficients' #quo), returning quotient and rest. </span><span
    class="inferred0"><a name="line166"></a>166 # If dividend and divisor have
    Intenger or Rational coefficients, </span><span class="inferred1"><a
    name="line167"></a>167 # then both quotient and rest will have Rational
    coefficients. </span><span class="inferred0"><a name="line168"></a>168 # If
    +divisor+ is a polynomial, uses polynomial long division. </span><span
    class="inferred1"><a name="line169"></a>169 # Otherwise, performs the
    division direclty on the coefficients. </span><span class="inferred0"><a
    name="line170"></a>170 # </span><span class="marked1"><a
    name="line171"></a>171 def quomod(divisor) </span><span class="marked0"><a
    name="line172"></a>172 case divisor </span><span class="marked1"><a
    name="line173"></a>173 when Numeric </span><span class="marked0"><a
    name="line174"></a>174 new_coefs = @coefs.map {|a| a.quo(divisor) }
    </span><span class="marked1"><a name="line175"></a>175 q, r =
    Polynomial.new(new_coefs), 0 </span><span class="marked0"><a
    name="line176"></a>176 when Polynomial </span><span class="marked1"><a
    name="line177"></a>177 a = self; b = divisor; q = 0; r = self </span><span
    class="marked0"><a name="line178"></a>178 (a.degree - b.degree + 1).times do
    </span><span class="marked1"><a name="line179"></a>179 dd = r.degree -
    b.degree </span><span class="marked0"><a name="line180"></a>180 qqa =
    r.coefs[-1].quo(b.coefs[-1]) </span><span class="marked1"><a
    name="line181"></a>181 qq = Polynomial[dd =&gt; qqa] </span><span
    class="marked0"><a name="line182"></a>182 q += qq </span><span
    class="marked1"><a name="line183"></a>183 r -= qq * divisor </span><span
    class="marked0"><a name="line184"></a>184 break if r.zero? </span><span
    class="inferred1"><a name="line185"></a>185 end </span><span
    class="inferred0"><a name="line186"></a>186 else </span><span
    class="marked1"><a name="line187"></a>187 raise ArgumentError, 'divisor
    should be Numeric or Polynomial' </span><span class="inferred0"><a
    name="line188"></a>188 end </span><span class="marked1"><a
    name="line189"></a>189 [q, r] </span><span class="inferred0"><a
    name="line190"></a>190 end </span><span class="inferred1"><a
    name="line191"></a>191 </span><span class="inferred0"><a
    name="line192"></a>192 # Divides by +divisor+ (using coefficients' #quo),
    which may be a number </span><span class="inferred1"><a
    name="line193"></a>193 # or another polynomial, which need not be divisible
    by the former. </span><span class="inferred0"><a name="line194"></a>194 # If
    dividend and divisor have Intenger or Rational coefficients, </span><span
    class="inferred1"><a name="line195"></a>195 # then the quotient will have
    Rational coefficients. </span><span class="inferred0"><a
    name="line196"></a>196 # </span><span class="inferred1"><a
    name="line197"></a>197 # </span><span class="marked0"><a
    name="line198"></a>198 def quo(divisor) </span><span class="marked1"><a
    name="line199"></a>199 quomod(divisor).first </span><span
    class="inferred0"><a name="line200"></a>200 end </span><span
    class="inferred1"><a name="line201"></a>201 </span><span
    class="inferred0"><a name="line202"></a>202 # Divides by +divisor+, returing
    quotient and rest. </span><span class="inferred1"><a name="line203"></a>203
    # If +divisor+ is a polynomial, uses polynomial long division. </span><span
    class="inferred0"><a name="line204"></a>204 # Otherwise, performs the
    division direclty on the coefficients. </span><span class="inferred1"><a
    name="line205"></a>205 # </span><span class="marked0"><a
    name="line206"></a>206 def divmod(divisor) </span><span class="marked1"><a
    name="line207"></a>207 case divisor </span><span class="marked0"><a
    name="line208"></a>208 when Numeric </span><span class="marked1"><a
    name="line209"></a>209 new_coefs = @coefs.map do |a| </span><span
    class="marked0"><a name="line210"></a>210 if divisor.is_a?(Integer)
    </span><span class="marked1"><a name="line211"></a>211 qq, rr =
    a.divmod(divisor) </span><span class="marked0"><a name="line212"></a>212 if
    rr.zero? then qq else a / divisor.to_f end </span><span class="inferred1"><a
    name="line213"></a>213 else </span><span class="marked0"><a
    name="line214"></a>214 a / divisor </span><span class="inferred1"><a
    name="line215"></a>215 end </span><span class="inferred0"><a
    name="line216"></a>216 end </span><span class="marked1"><a
    name="line217"></a>217 q, r = Polynomial.new(new_coefs), 0 </span><span
    class="marked0"><a name="line218"></a>218 when Polynomial </span><span
    class="marked1"><a name="line219"></a>219 a = self; b = divisor; q = 0; r =
    self </span><span class="marked0"><a name="line220"></a>220 (a.degree -
    b.degree + 1).times do </span><span class="marked1"><a
    name="line221"></a>221 dd = r.degree - b.degree </span><span
    class="marked0"><a name="line222"></a>222 qqa = r.coefs[-1] /
    (b.coefs[-1].to_f rescue b.coefs[-1]) # rescue for complex numbers
    </span><span class="marked1"><a name="line223"></a>223 qq = Polynomial[dd
    =&gt; qqa] </span><span class="marked0"><a name="line224"></a>224 q += qq
    </span><span class="marked1"><a name="line225"></a>225 r -= qq * divisor
    </span><span class="marked0"><a name="line226"></a>226 break if r.zero?
    </span><span class="inferred1"><a name="line227"></a>227 end </span><span
    class="inferred0"><a name="line228"></a>228 else </span><span
    class="marked1"><a name="line229"></a>229 raise ArgumentError, 'divisor
    should be Numeric or Polynomial' </span><span class="inferred0"><a
    name="line230"></a>230 end </span><span class="marked1"><a
    name="line231"></a>231 [q, r] </span><span class="inferred0"><a
    name="line232"></a>232 end </span><span class="inferred1"><a
    name="line233"></a>233 </span><span class="inferred0"><a
    name="line234"></a>234 # Divides polynomial by a number or another
    polynomial, </span><span class="inferred1"><a name="line235"></a>235 # which
    need not be divisible by the former. </span><span class="inferred0"><a
    name="line236"></a>236 # </span><span class="marked1"><a
    name="line237"></a>237 def div(other) </span><span class="marked0"><a
    name="line238"></a>238 divmod(other).first </span><span class="inferred1"><a
    name="line239"></a>239 end </span><span class="marked0"><a
    name="line240"></a>240 alias / div </span><span class="inferred1"><a
    name="line241"></a>241 </span><span class="marked0"><a
    name="line242"></a>242 def %(other) </span><span class="marked1"><a
    name="line243"></a>243 divmod(other).last </span><span class="inferred0"><a
    name="line244"></a>244 end </span><span class="inferred1"><a
    name="line245"></a>245 </span><span class="marked0"><a
    name="line246"></a>246 def **(n) </span><span class="marked1"><a
    name="line247"></a>247 raise ArgumentError, &quot;negative argument&quot; if
    n &lt; 0 </span><span class="marked0"><a name="line248"></a>248 result =
    Polynomial[1] </span><span class="marked1"><a name="line249"></a>249 n.times
    do </span><span class="marked0"><a name="line250"></a>250 result *= self
    </span><span class="inferred1"><a name="line251"></a>251 end </span><span
    class="marked0"><a name="line252"></a>252 result </span><span
    class="inferred1"><a name="line253"></a>253 end </span><span
    class="inferred0"><a name="line254"></a>254 </span><span
    class="inferred1"><a name="line255"></a>255 # Computes polynomial's definite
    integral (which is itself a polynomial). </span><span class="inferred0"><a
    name="line256"></a>256 # </span><span class="marked1"><a
    name="line257"></a>257 def integral </span><span class="marked0"><a
    name="line258"></a>258 a = Array.new(@coefs.size+1) </span><span
    class="marked1"><a name="line259"></a>259 a[0] = 0 </span><span
    class="marked0"><a name="line260"></a>260 @coefs.each.with_index do |coef,
    n| </span><span class="marked1"><a name="line261"></a>261 if
    coef.is_a?(Integer) &amp;&amp; coef.modulo(n+1).zero? </span><span
    class="marked0"><a name="line262"></a>262 a[n+1] = coef / (n + 1)
    </span><span class="inferred1"><a name="line263"></a>263 else </span><span
    class="marked0"><a name="line264"></a>264 a[n+1] = coef / (n + 1.0)
    </span><span class="inferred1"><a name="line265"></a>265 end </span><span
    class="inferred0"><a name="line266"></a>266 end </span><span
    class="marked1"><a name="line267"></a>267 Polynomial.new(a) </span><span
    class="inferred0"><a name="line268"></a>268 end </span><span
    class="inferred1"><a name="line269"></a>269 </span><span
    class="inferred0"><a name="line270"></a>270 # Computes polynomial's
    derivative (which is itself a polynomial). </span><span class="inferred1"><a
    name="line271"></a>271 # </span><span class="marked0"><a
    name="line272"></a>272 def derivative </span><span class="marked1"><a
    name="line273"></a>273 if degree &gt; 0 </span><span class="marked0"><a
    name="line274"></a>274 a = Array.new(@coefs.size-1) </span><span
    class="marked1"><a name="line275"></a>275 a.each_index { |n| a[n] = (n+1) *
    @coefs[n+1] } </span><span class="inferred0"><a name="line276"></a>276 else
    </span><span class="marked1"><a name="line277"></a>277 a = [0] </span><span
    class="inferred0"><a name="line278"></a>278 end </span><span
    class="marked1"><a name="line279"></a>279 Polynomial.new(a) </span><span
    class="inferred0"><a name="line280"></a>280 end </span><span
    class="inferred1"><a name="line281"></a>281 </span><span
    class="inferred0"><a name="line282"></a>282 # Generate the string
    corresponding to the polynomial. </span><span class="inferred1"><a
    name="line283"></a>283 # If :verbose is false (default), omits
    zero-coefficiented monomials. </span><span class="inferred0"><a
    name="line284"></a>284 # If :spaced is true (default), monomials are spaced.
    </span><span class="inferred1"><a name="line285"></a>285 # If :decreasing is
    false (default), monomials are present from </span><span
    class="inferred0"><a name="line286"></a>286 # lowest to greatest degree.
    </span><span class="inferred1"><a name="line287"></a>287 # </span><span
    class="inferred0"><a name="line288"></a>288 # Examples: </span><span
    class="inferred1"><a name="line289"></a>289 # Polynomial[1,-2,3].to_s #=&gt;
    &quot;1 - 2*x + 3*x**2&quot; </span><span class="inferred0"><a
    name="line290"></a>290 # Polynomial[1,-2,3].to_s(:spaced=&gt;false) #=&gt;
    &quot;1-2*x+3*x**2&quot; </span><span class="inferred1"><a
    name="line291"></a>291 # Polynomial[1,-2,3].to_s(:decreasing=&gt;true)
    #=&gt; &quot;3*x**2 - 2*x + 1&quot; </span><span class="inferred0"><a
    name="line292"></a>292 # Polynomial[1,0,3].to_s(:verbose=&gt;true) #=&gt;
    &quot;1 + 0*x + 3*x**2&quot; </span><span class="inferred1"><a
    name="line293"></a>293 # </span><span class="inferred0"><a
    name="line294"></a>294 # </span><span class="marked1"><a
    name="line295"></a>295 ToSDefaults = HandyHash[ </span><span
    class="inferred0"><a name="line296"></a>296 :verbose =&gt; false,
    </span><span class="inferred1"><a name="line297"></a>297 :spaced =&gt; true,
    </span><span class="inferred0"><a name="line298"></a>298 :power_symbol =&gt;
    '**', </span><span class="inferred1"><a name="line299"></a>299
    :multiplication_symbol =&gt; '*', </span><span class="inferred0"><a
    name="line300"></a>300 :variable_name =&gt; 'x', </span><span
    class="inferred1"><a name="line301"></a>301 :decreasing =&gt; false
    </span><span class="inferred0"><a name="line302"></a>302 ] </span><span
    class="marked1"><a name="line303"></a>303 def to_s(params={}) </span><span
    class="marked0"><a name="line304"></a>304 params =
    ToSDefaults.merge_abbrv(params) </span><span class="marked1"><a
    name="line305"></a>305 mult = params[:multiplication_symbol] </span><span
    class="marked0"><a name="line306"></a>306 pow = params[:power_symbol]
    </span><span class="marked1"><a name="line307"></a>307 var =
    params[:variable_name] </span><span class="marked0"><a
    name="line308"></a>308 coefs_index_enumerator = if params[:decreasing]
    </span><span class="marked1"><a name="line309"></a>309
    @coefs.each.with_index.reverse_each </span><span class="inferred0"><a
    name="line310"></a>310 else </span><span class="marked1"><a
    name="line311"></a>311 @coefs.each.with_index </span><span
    class="inferred0"><a name="line312"></a>312 end </span><span
    class="marked1"><a name="line313"></a>313 result = '' </span><span
    class="marked0"><a name="line314"></a>314 coefs_index_enumerator.each do
    |a,n| </span><span class="marked1"><a name="line315"></a>315 next if a.zero?
    &amp;&amp; !params[:verbose] </span><span class="marked0"><a
    name="line316"></a>316 result += '+' unless result.empty? </span><span
    class="marked1"><a name="line317"></a>317 coef_str = a.to_s </span><span
    class="marked0"><a name="line318"></a>318 coef_str = '(' + coef_str + ')' if
    coef_str[/[+\/]/] </span><span class="marked1"><a name="line319"></a>319
    result += coef_str unless a == 1 &amp;&amp; n &gt; 0 </span><span
    class="marked0"><a name="line320"></a>320 result += &quot;#{mult}&quot; if a
    != 1 &amp;&amp; n &gt; 0 </span><span class="marked1"><a
    name="line321"></a>321 result += &quot;#{var}&quot; if n &gt;= 1
    </span><span class="marked0"><a name="line322"></a>322 result +=
    &quot;#{pow}#{n}&quot; if n &gt;= 2 </span><span class="inferred1"><a
    name="line323"></a>323 end </span><span class="marked0"><a
    name="line324"></a>324 result.gsub!(/\+-/,'-') </span><span
    class="marked1"><a name="line325"></a>325
    result.gsub!(/([^e\(])(\+|-)(.)/,'\1 \2 \3') if params.spaced </span><span
    class="marked0"><a name="line326"></a>326 result </span><span
    class="inferred1"><a name="line327"></a>327 end </span><span
    class="inferred0"><a name="line328"></a>328 </span><span
    class="inferred1"><a name="line329"></a>329 # Converts a zero-degree
    polynomial to a number (i.e., its only coefficient). </span><span
    class="inferred0"><a name="line330"></a>330 # </span><span
    class="marked1"><a name="line331"></a>331 def to_num </span><span
    class="marked0"><a name="line332"></a>332 if self.degree == 0 </span><span
    class="marked1"><a name="line333"></a>333 @coefs[0] </span><span
    class="inferred0"><a name="line334"></a>334 else </span><span
    class="marked1"><a name="line335"></a>335 raise ArgumentError, &quot;can't
    convert Polynomial of positive degree to Numeric&quot; </span><span
    class="inferred0"><a name="line336"></a>336 end </span><span
    class="inferred1"><a name="line337"></a>337 end </span><span
    class="marked0"><a name="line338"></a>338 def to_f; to_num.to_f; end
    </span><span class="marked1"><a name="line339"></a>339 def to_i;
    to_num.to_i; end </span><span class="inferred0"><a name="line340"></a>340
    </span><span class="inferred1"><a name="line341"></a>341 # If EasyPlot can
    be loaded, plot method is defined. </span><span class="marked0"><a
    name="line342"></a>342 begin </span><span class="marked1"><a
    name="line343"></a>343 require 'easy_plot' </span><span class="inferred0"><a
    name="line344"></a>344 </span><span class="inferred1"><a
    name="line345"></a>345 # Plots polynomial using EasyPlot. </span><span
    class="inferred0"><a name="line346"></a>346 # </span><span
    class="marked1"><a name="line347"></a>347 def plot(params={}) </span><span
    class="uncovered0"><a name="line348"></a>348 EasyPlot.plot(self.to_s,
    params) </span><span class="uncovered1"><a name="line349"></a>349 end
    </span><span class="uncovered0"><a name="line350"></a>350 rescue LoadError
    </span><span class="uncovered1"><a name="line351"></a>351 $stderr.puts
    'EasyPlot could not be loaded, thus plotting convenience methods were not
    defined.' </span><span class="uncovered0"><a name="line352"></a>352 end
    </span><span class="inferred1"><a name="line353"></a>353 </span><span
    class="marked0"><a name="line354"></a>354 attr_reader :coefs </span><span
    class="inferred1"><a name="line355"></a>355 </span><span
    class="inferred0"><a name="line356"></a>356 # Compares with another
    Polynomial by degrees then coefficients. </span><span class="inferred1"><a
    name="line357"></a>357 # </span><span class="marked0"><a
    name="line358"></a>358 def &lt;=&gt;(other) </span><span class="marked1"><a
    name="line359"></a>359 case other </span><span class="marked0"><a
    name="line360"></a>360 when Numeric </span><span class="marked1"><a
    name="line361"></a>361 [self.degree, @coefs[0]] &lt;=&gt; [0, other]
    </span><span class="marked0"><a name="line362"></a>362 when Polynomial
    </span><span class="marked1"><a name="line363"></a>363 [self.degree, @coefs]
    &lt;=&gt; [other.degree, other.coefs] </span><span class="inferred0"><a
    name="line364"></a>364 else </span><span class="marked1"><a
    name="line365"></a>365 raise TypeError, &quot;can't compare #{other.class}
    to Polynomial&quot; </span><span class="inferred0"><a name="line366"></a>366
    end </span><span class="inferred1"><a name="line367"></a>367 end
    </span><span class="marked0"><a name="line368"></a>368 include Comparable
    </span><span class="inferred1"><a name="line369"></a>369 </span><span
    class="inferred0"><a name="line370"></a>370 # Returns true if the other
    Polynomial has same degree and close-enough </span><span
    class="inferred1"><a name="line371"></a>371 # (up to delta absolute
    difference) coefficients. Returns false otherwise. </span><span
    class="inferred0"><a name="line372"></a>372 # </span><span
    class="marked1"><a name="line373"></a>373 def equal_in_delta(other, delta)
    </span><span class="marked0"><a name="line374"></a>374 return false unless
    self.degree == other.degree </span><span class="marked1"><a
    name="line375"></a>375 for n in 0 .. degree </span><span class="marked0"><a
    name="line376"></a>376 return false unless (@coefs[n] - other.coefs[n]).abs
    &lt;= delta </span><span class="inferred1"><a name="line377"></a>377 end
    </span><span class="marked0"><a name="line378"></a>378 true </span><span
    class="inferred1"><a name="line379"></a>379 end </span><span
    class="inferred0"><a name="line380"></a>380 </span><span class="marked1"><a
    name="line381"></a>381 private </span><span class="inferred0"><a
    name="line382"></a>382 </span><span class="marked1"><a
    name="line383"></a>383 def self.remove_trailing_zeroes(ary) </span><span
    class="marked0"><a name="line384"></a>384 m = 0 </span><span
    class="marked1"><a name="line385"></a>385 ary.reverse.each.with_index do
    |a,n| </span><span class="marked0"><a name="line386"></a>386 unless a.zero?
    </span><span class="marked1"><a name="line387"></a>387 m = n+1 </span><span
    class="marked0"><a name="line388"></a>388 break </span><span
    class="inferred1"><a name="line389"></a>389 end </span><span
    class="inferred0"><a name="line390"></a>390 end </span><span
    class="marked1"><a name="line391"></a>391 ary[0..-m] </span><span
    class="inferred0"><a name="line392"></a>392 end </span><span
    class="inferred1"><a name="line393"></a>393 </span><span
    class="inferred0"><a name="line394"></a>394 # Converts a
    power-to-coefficient Hash into the Array of coefficients. </span><span
    class="inferred1"><a name="line395"></a>395 # </span><span
    class="marked0"><a name="line396"></a>396 def
    self.coefs_from_pow_coefs(hash, params={}) </span><span class="marked1"><a
    name="line397"></a>397 power_coefs = Hash.new(0).merge(hash) </span><span
    class="marked0"><a name="line398"></a>398 (0..power_coefs.keys.max).map {|p|
    power_coefs[p] } </span><span class="inferred1"><a name="line399"></a>399
    end </span><span class="inferred0"><a name="line400"></a>400 </span><span
    class="inferred1"><a name="line401"></a>401 # Extracts the Array of
    coefficients from a String. </span><span class="inferred0"><a
    name="line402"></a>402 # </span><span class="marked1"><a
    name="line403"></a>403 def self.coefs_from_string(s, params={}) </span><span
    class="marked0"><a name="line404"></a>404 h = pow_coefs_from_string(s,
    params) </span><span class="marked1"><a name="line405"></a>405
    coefs_from_pow_coefs(h, params) </span><span class="inferred0"><a
    name="line406"></a>406 end </span><span class="inferred1"><a
    name="line407"></a>407 </span><span class="inferred0"><a
    name="line408"></a>408 # Extracts a power-to-coefficient Hash from a String.
    </span><span class="inferred1"><a name="line409"></a>409 # </span><span
    class="marked0"><a name="line410"></a>410 def self.pow_coefs_from_string(s,
    params={}) </span><span class="marked1"><a name="line411"></a>411 h =
    Hash.new(0) </span><span class="inferred0"><a name="line412"></a>412 begin
    </span><span class="marked1"><a name="line413"></a>413 power, coef, s =
    parse_term(s, params) </span><span class="marked0"><a name="line414"></a>414
    h[power] += coef </span><span class="marked1"><a name="line415"></a>415 end
    until s.strip.empty? </span><span class="marked0"><a name="line416"></a>416
    h </span><span class="inferred1"><a name="line417"></a>417 end </span><span
    class="inferred0"><a name="line418"></a>418 </span><span
    class="inferred1"><a name="line419"></a>419 # Parses a single polynomial
    term (i.e., a monomial). Returns an array with </span><span
    class="inferred0"><a name="line420"></a>420 # degree (power), coeficient and
    the remainder of the string, which may </span><span class="inferred1"><a
    name="line421"></a>421 # contains other terms. </span><span
    class="inferred0"><a name="line422"></a>422 # </span><span
    class="inferred1"><a name="line423"></a>423 # Example: </span><span
    class="inferred0"><a name="line424"></a>424 #
    Polynomial.parse_term('x**2-3') #=&gt; [2, 1, '-3'] </span><span
    class="inferred1"><a name="line425"></a>425 # Polynomial.parse_term('4')
    #=&gt; [0, 4, ''] </span><span class="inferred0"><a name="line426"></a>426 #
    </span><span class="marked1"><a name="line427"></a>427 def
    self.parse_term(string, params={}) </span><span class="marked0"><a
    name="line428"></a>428 params = FromStringDefaults.merge(params)
    </span><span class="marked1"><a name="line429"></a>429 mult =
    Regexp.escape(params[:multiplication_symbol]) </span><span
    class="marked0"><a name="line430"></a>430 pow_sym =
    Regexp.escape(params[:power_symbol]) </span><span class="marked1"><a
    name="line431"></a>431 var = Regexp.escape(params[:variable_name])
    </span><span class="marked0"><a name="line432"></a>432 opt_sign = '(\+|-)?'
    </span><span class="marked1"><a name="line433"></a>433 int = '(\d+)'
    </span><span class="marked0"><a name="line434"></a>434 decimal =
    '(\d+(?:\.\d+)?(?:[eE]\-?\d+)?)' </span><span class="marked1"><a
    name="line435"></a>435 opt_space = '\s*' </span><span class="marked0"><a
    name="line436"></a>436 anything = '(.*)' </span><span class="marked1"><a
    name="line437"></a>437 tbp = string.strip # tbp stands for 'to be parsed'
    </span><span class="marked0"><a name="line438"></a>438 power, coef = nil,
    nil # scope reasons </span><span class="marked1"><a name="line439"></a>439
    make_regex = lambda {|core| Regexp.new('^' + core + '$') } </span><span
    class="inferred0"><a name="line440"></a>440 </span><span
    class="inferred1"><a name="line441"></a>441 # matches terms starting with
    numbers, possibly signed, such as '1', '2.5', '- 3.3', '3*x', '4*x**2'
    </span><span class="marked0"><a name="line442"></a>442 if md =
    make_regex[opt_sign + opt_space + decimal + anything].match(tbp)
    </span><span class="marked1"><a name="line443"></a>443 sn = md[1] ?
    md[1]+md[2] : md[2] </span><span class="marked0"><a name="line444"></a>444
    coef = Integer(sn) rescue Float(sn) </span><span class="marked1"><a
    name="line445"></a>445 tbp = md[-1] </span><span class="marked0"><a
    name="line446"></a>446 if md = make_regex[mult + var + anything].match(tbp)
    </span><span class="marked1"><a name="line447"></a>447 tbp = md[-1]
    </span><span class="marked0"><a name="line448"></a>448 if md =
    make_regex[pow_sym + int + anything].match(tbp) </span><span
    class="marked1"><a name="line449"></a>449 power = Integer(md[1])
    </span><span class="marked0"><a name="line450"></a>450 tbp = md[-1]
    </span><span class="inferred1"><a name="line451"></a>451 else </span><span
    class="marked0"><a name="line452"></a>452 power = 1 </span><span
    class="inferred1"><a name="line453"></a>453 end </span><span
    class="inferred0"><a name="line454"></a>454 else </span><span
    class="marked1"><a name="line455"></a>455 power = 0 </span><span
    class="inferred0"><a name="line456"></a>456 end </span><span
    class="inferred1"><a name="line457"></a>457 # matches terms starting with
    variable, such as 'x', 'x**2' </span><span class="marked0"><a
    name="line458"></a>458 elsif md = make_regex.call(opt_sign + opt_space + var
    + anything).match(tbp) </span><span class="marked1"><a
    name="line459"></a>459 power, coef, tbp = 1, 1, md[-1].strip </span><span
    class="marked0"><a name="line460"></a>460 if md = make_regex[pow_sym + int +
    anything].match(tbp) </span><span class="marked1"><a name="line461"></a>461
    power = Integer(md[1]) </span><span class="marked0"><a
    name="line462"></a>462 tbp = md[-1] </span><span class="inferred1"><a
    name="line463"></a>463 end </span><span class="inferred0"><a
    name="line464"></a>464 end </span><span class="marked1"><a
    name="line465"></a>465 unless [power, coef].none? {|val| val.nil? }
    &amp;&amp; (tbp[/^\s*\+|-/] || tbp.empty?) </span><span class="marked0"><a
    name="line466"></a>466 raise ArgumentError, &quot;invalid value for
    Polynomial: \&quot;#{string}\&quot;&quot; </span><span class="inferred1"><a
    name="line467"></a>467 end </span><span class="marked0"><a
    name="line468"></a>468 [power, coef, tbp] </span><span class="inferred1"><a
    name="line469"></a>469 end </span><span class="inferred0"><a
    name="line470"></a>470 </span><span class="inferred1"><a
    name="line471"></a>471 end </span></pre>
    <hr />
    <p> Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'> rcov
    code coverage analysis tool for Ruby </a> version 0.8.1.2. </p>
    <p>
      <a href='http://validator.w3.org/check/referer'>
        <img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' />
      </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'>
        <img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' />
      </a>
    </p>
  </body>
</html>
